/*
 * Restler API Explorer
 *
 * Live API Documentation
 *
 * OpenAPI spec version: 1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel.DataAnnotations;
using System.Runtime.Serialization;
using Newtonsoft.Json;

namespace IO.Swagger.Models
{ 
    /// <summary>
    /// OutputAddressValidationInfo Model
    /// </summary>
    [DataContract]
    public partial class OutputAddressValidationInfo : IEquatable<OutputAddressValidationInfo>
    { 
        /// <summary>
        /// true if the supplied string is an address BlockTrades can initiate a transfer to. This might be an address, public key, account name, or account number, depending on what the output wallet requires.
        /// </summary>
        /// <value>true if the supplied string is an address BlockTrades can initiate a transfer to. This might be an address, public key, account name, or account number, depending on what the output wallet requires.</value>
        [Required]
        [DataMember(Name="isValid")]
        public string IsValid { get; set; }

        /// <summary>
        /// true if the supplied string names a registered account. This was only important for BitShares 0.x, where you could send to both unregistered public keys (isAccount would report false) and named registered accounts (isAccount would report true). We still Today, all of the wallets we support either support accounts or addresses, but never both. This flag tells you which.
        /// </summary>
        /// <value>true if the supplied string names a registered account. This was only important for BitShares 0.x, where you could send to both unregistered public keys (isAccount would report false) and named registered accounts (isAccount would report true). We still Today, all of the wallets we support either support accounts or addresses, but never both. This flag tells you which.</value>
        [Required]
        [DataMember(Name="isAccount")]
        public string IsAccount { get; set; }

        /// <summary>
        /// true if address is on black list.
        /// </summary>
        /// <value>true if address is on black list.</value>
        [Required]
        [DataMember(Name="isBlacklisted")]
        public string IsBlacklisted { get; set; }

        /// <summary>
        /// the avatar for the account (currently only supported on Steem), this will be an image URL
        /// </summary>
        /// <value>the avatar for the account (currently only supported on Steem), this will be an image URL</value>
        [DataMember(Name="avatar")]
        public string Avatar { get; set; }

        /// <summary>
        /// the name on the account (currently only supported on Steem)
        /// </summary>
        /// <value>the name on the account (currently only supported on Steem)</value>
        [DataMember(Name="name")]
        public string Name { get; set; }

        /// <summary>
        /// the account number (currently only supported on Bitshares-like blockchains)
        /// </summary>
        /// <value>the account number (currently only supported on Bitshares-like blockchains)</value>
        [DataMember(Name="accountNumber")]
        public string AccountNumber { get; set; }

        /// <summary>
        /// if this is a phishing account, this is the real account the phisher was trying to spoof These accounts will always have isBlacklist &#x3D; true. (but the converse is not true, some blacklisted accounts aren&#39;t phishing accounts)
        /// </summary>
        /// <value>if this is a phishing account, this is the real account the phisher was trying to spoof These accounts will always have isBlacklist &#x3D; true. (but the converse is not true, some blacklisted accounts aren&#39;t phishing accounts)</value>
        [DataMember(Name="correctAddress")]
        public string CorrectAddress { get; set; }

        /// <summary>
        /// true if BlockTrades expects a non-empty memo to be provided for transfers to this address (usually true for exchanges which require a memo to determine which account to credit)
        /// </summary>
        /// <value>true if BlockTrades expects a non-empty memo to be provided for transfers to this address (usually true for exchanges which require a memo to determine which account to credit)</value>
        [DataMember(Name="memoExpected")]
        public string MemoExpected { get; set; }

        /// <summary>
        /// if the memo has particular significance, a string describing it
        /// </summary>
        /// <value>if the memo has particular significance, a string describing it</value>
        [DataMember(Name="memoPlaceholderText")]
        public string MemoPlaceholderText { get; set; }

        /// <summary>
        /// true if account name is similat to one of exising exchange name
        /// </summary>
        /// <value>true if account name is similat to one of exising exchange name</value>
        [DataMember(Name="similarToExistingService")]
        public string SimilarToExistingService { get; set; }

        /// <summary>
        /// the balances of the account (for blockchains that support this)
        /// </summary>
        /// <value>the balances of the account (for blockchains that support this)</value>
        [DataMember(Name="balances")]
        public string Balances { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class OutputAddressValidationInfo {\n");
            sb.Append("  IsValid: ").Append(IsValid).Append("\n");
            sb.Append("  IsAccount: ").Append(IsAccount).Append("\n");
            sb.Append("  IsBlacklisted: ").Append(IsBlacklisted).Append("\n");
            sb.Append("  Avatar: ").Append(Avatar).Append("\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  AccountNumber: ").Append(AccountNumber).Append("\n");
            sb.Append("  CorrectAddress: ").Append(CorrectAddress).Append("\n");
            sb.Append("  MemoExpected: ").Append(MemoExpected).Append("\n");
            sb.Append("  MemoPlaceholderText: ").Append(MemoPlaceholderText).Append("\n");
            sb.Append("  SimilarToExistingService: ").Append(SimilarToExistingService).Append("\n");
            sb.Append("  Balances: ").Append(Balances).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="obj">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            return obj.GetType() == GetType() && Equals((OutputAddressValidationInfo)obj);
        }

        /// <summary>
        /// Returns true if OutputAddressValidationInfo instances are equal
        /// </summary>
        /// <param name="other">Instance of OutputAddressValidationInfo to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(OutputAddressValidationInfo other)
        {
            if (ReferenceEquals(null, other)) return false;
            if (ReferenceEquals(this, other)) return true;

            return 
                (
                    IsValid == other.IsValid ||
                    IsValid != null &&
                    IsValid.Equals(other.IsValid)
                ) && 
                (
                    IsAccount == other.IsAccount ||
                    IsAccount != null &&
                    IsAccount.Equals(other.IsAccount)
                ) && 
                (
                    IsBlacklisted == other.IsBlacklisted ||
                    IsBlacklisted != null &&
                    IsBlacklisted.Equals(other.IsBlacklisted)
                ) && 
                (
                    Avatar == other.Avatar ||
                    Avatar != null &&
                    Avatar.Equals(other.Avatar)
                ) && 
                (
                    Name == other.Name ||
                    Name != null &&
                    Name.Equals(other.Name)
                ) && 
                (
                    AccountNumber == other.AccountNumber ||
                    AccountNumber != null &&
                    AccountNumber.Equals(other.AccountNumber)
                ) && 
                (
                    CorrectAddress == other.CorrectAddress ||
                    CorrectAddress != null &&
                    CorrectAddress.Equals(other.CorrectAddress)
                ) && 
                (
                    MemoExpected == other.MemoExpected ||
                    MemoExpected != null &&
                    MemoExpected.Equals(other.MemoExpected)
                ) && 
                (
                    MemoPlaceholderText == other.MemoPlaceholderText ||
                    MemoPlaceholderText != null &&
                    MemoPlaceholderText.Equals(other.MemoPlaceholderText)
                ) && 
                (
                    SimilarToExistingService == other.SimilarToExistingService ||
                    SimilarToExistingService != null &&
                    SimilarToExistingService.Equals(other.SimilarToExistingService)
                ) && 
                (
                    Balances == other.Balances ||
                    Balances != null &&
                    Balances.Equals(other.Balances)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                var hashCode = 41;
                // Suitable nullity checks etc, of course :)
                    if (IsValid != null)
                    hashCode = hashCode * 59 + IsValid.GetHashCode();
                    if (IsAccount != null)
                    hashCode = hashCode * 59 + IsAccount.GetHashCode();
                    if (IsBlacklisted != null)
                    hashCode = hashCode * 59 + IsBlacklisted.GetHashCode();
                    if (Avatar != null)
                    hashCode = hashCode * 59 + Avatar.GetHashCode();
                    if (Name != null)
                    hashCode = hashCode * 59 + Name.GetHashCode();
                    if (AccountNumber != null)
                    hashCode = hashCode * 59 + AccountNumber.GetHashCode();
                    if (CorrectAddress != null)
                    hashCode = hashCode * 59 + CorrectAddress.GetHashCode();
                    if (MemoExpected != null)
                    hashCode = hashCode * 59 + MemoExpected.GetHashCode();
                    if (MemoPlaceholderText != null)
                    hashCode = hashCode * 59 + MemoPlaceholderText.GetHashCode();
                    if (SimilarToExistingService != null)
                    hashCode = hashCode * 59 + SimilarToExistingService.GetHashCode();
                    if (Balances != null)
                    hashCode = hashCode * 59 + Balances.GetHashCode();
                return hashCode;
            }
        }

        #region Operators
        #pragma warning disable 1591

        public static bool operator ==(OutputAddressValidationInfo left, OutputAddressValidationInfo right)
        {
            return Equals(left, right);
        }

        public static bool operator !=(OutputAddressValidationInfo left, OutputAddressValidationInfo right)
        {
            return !Equals(left, right);
        }

        #pragma warning restore 1591
        #endregion Operators
    }
}
